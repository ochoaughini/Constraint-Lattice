#!/usr/bin/env python3
"""Generate an aggregated LICENSE-MAP.md at repository root.

The script discovers every `.license` JSON file in the repository, parses the
metadata, and writes an auditable Markdown table that summarizes the license
ownership boundaries. Each entry includes a SHA256 checksum so external parties
can verify the contents have not changed since generation time.
"""
from __future__ import annotations

import hashlib
import json
import os
from pathlib import Path
from textwrap import dedent

REPO_ROOT = Path(__file__).resolve().parents[1]
OUTPUT_FILE = REPO_ROOT / "LICENSE-MAP.md"


def iter_license_files(root: Path):
    """Yield all `.license` file paths in the repository."""
    for path in root.rglob(".license"):
        # Ignore virtual environments / git dirs
        parts = set(part.lower() for part in path.parts)
        if ".venv" in parts or ".git" in parts:
            continue
        yield path


def parse_license_file(path: Path):
    """Return dict with directory (relative), license, scope, owner, sha256."""
    rel_dir = path.parent.relative_to(REPO_ROOT)
    data = json.loads(path.read_text())
    checksum = hashlib.sha256(path.read_bytes()).hexdigest()
    return {
        "directory": f"/{rel_dir.as_posix()}" if rel_dir != Path('.') else "/",
        "license": data.get("license", "UNKNOWN"),
        "scope": data.get("scope", "unknown"),
        "owner": data.get("owner", "unknown"),
        "sha256": checksum,
    }


def build_markdown(rows: list[dict]):
    header = dedent(
        """
        # Constraint-Lattice License Map
        This file is auto-generated by `tools/gen_license_map.py`.
        It provides a canonical, cryptographically verifiable view of directory-level
        licensing for auditors, contributors and customers.
        """
    ).strip()

    table_header = "| Directory | License | Scope | Owner | SHA256 |\n|---|---|---|---|---|"
    table_rows = [
        f"| {r['directory']} | {r['license']} | {r['scope']} | {r['owner']} | `{r['sha256'][:12]}â€¦` |"
        for r in sorted(rows, key=lambda x: x["directory"])
    ]
    return "\n".join([header, "", table_header, *table_rows, ""])


def main():
    rows = [parse_license_file(p) for p in iter_license_files(REPO_ROOT)]
    markdown = build_markdown(rows)
    OUTPUT_FILE.write_text(markdown + "\n")
    print(f"Wrote {OUTPUT_FILE} with {len(rows)} entries.")


if __name__ == "__main__":
    main()
